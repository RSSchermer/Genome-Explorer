// Generated by CoffeeScript 1.6.3
/*
  glider 0.1.5 - AngularJS slider
  https://github.com/evrone/glider
  Copyright (c) 2013 Valentin Vasilyev, Dmitry Karpunin
  Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.

  examples:

  basic:
  <slider min="0" max="100" step="1" value="age"></slider>

  update only on mouse up:
  <slider defer_update min="0" max="100" step="1" value="age"></slider>

  show value in handle:
  <slider show_value_in_handle min="0" max="100" step="1" value="age"></slider>

  slider with increments (incompatible with step option)
  <slider min="0" max="100" increments="10,50,60,90"></slider>
*/


(function() {
  'use strict';
  var gliderModule;

  gliderModule = angular.module('glider', []);

  gliderModule.directive('slider', [
    '$document', function($document) {
      return {
        template: "<span class=\"g-slider horizontal\">\n<span class=\"slider\" ng-click=\"sliderClick($event)\">\n<span class=\"range\" ng-style=\"{width: xPosition+'%'}\"></span>\n<span class=\"handle\" ng-style=\"{left: xPosition +'%'}\" ng-mousedown=\"handleMouseDown($event)\">\n<span class=\"value\" ng-show=\"showValueInHandle\">{{handleValue | intersperse}}</span>\n</span>\n</span>\n<span class=\"side dec\">\n<span class=\"button\" ng-click=\"step(-1)\">-</span>\n<span class=\"bound-value\">{{min() | intersperse}}</span>\n</span>\n<span class=\"side inc\">\n<span class=\"button\" ng-click=\"step(+1)\">+</span>\n<span class=\"bound-value\">{{max() | intersperse}}</span>\n</span>\n<span class=\"increments\">\n<span ng-repeat=\"i in increments\" class=\"i\" ng-style=\"{left: i.offset+'%'}\">\n{{ i.value | intersperse }}\n</span>\n</span>\n</span>",
        replace: true,
        restrict: "E",
        scope: {
          value: "=",
          min: "&",
          max: "&"
        },
        link: function(scope, element, attrs) {
          var bound, deferUpdate, dragging, parseIncrements, refreshHandle, sliderElement, snap, startPointX, step, valueFromPosition;
          bound = function(value, min, max) {
            return Math.min(Math.max(min, value), max);
          };
          parseIncrements = function() {
            var i, max, min, offsetK, _i, _len, _ref;
            if (attrs.increments == null) {
              return;
            }
            min = scope.min();
            max = scope.max();
            if (!(isFinite(min) && isFinite(max))) {
              return;
            }
            offsetK = 100 / Math.abs(max - min);
            scope.increments = [];
            scope.snapValues = [min, max];
            _ref = attrs.increments.split(',');
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              i = _ref[_i];
              i = parseInt(i);
              if ((min < i && i < max)) {
                scope.increments.push({
                  value: i,
                  offset: (i - min) * offsetK
                });
                scope.snapValues.push(i);
              }
            }
            return scope.snapValues.sort(function(a, b) {
              return a - b;
            });
          };
          sliderElement = element[0].getElementsByClassName('slider')[0];
          dragging = false;
          scope.xPosition = 0;
          step = attrs.step || 1;
          deferUpdate = attrs.deferUpdate != null;
          scope.showValueInHandle = attrs.showValueInHandle != null;
          if (scope.value == null) {
            scope.value = scope.min();
          }
          refreshHandle = function() {
            var range;
            range = scope.max() - scope.min();
            if (range === 0) {
              scope.xPosition = 0;
            } else {
              scope.xPosition = (scope.value - scope.min()) / range * 100;
              scope.xPosition = bound(scope.xPosition, 0, 100);
            }
            if (scope.showValueInHandle) {
              return scope.handleValue = scope.value;
            }
          };
          snap = function() {
            var closestValue, diff, minDiff, snapValue, _i, _len, _ref;
            if (scope.increments) {
              minDiff = Infinity;
              _ref = scope.snapValues;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                snapValue = _ref[_i];
                diff = Math.abs(snapValue - scope.value);
                if (diff < minDiff) {
                  minDiff = diff;
                  closestValue = snapValue;
                }
              }
              if (isFinite(closestValue)) {
                scope.value = closestValue;
              }
            }
            return refreshHandle();
          };
          valueFromPosition = function() {
            return Math.round((((scope.max() - scope.min()) * (scope.xPosition / 100)) + scope.min()) / step) * step;
          };
          scope.$watch('min()', function(minValue) {
            parseIncrements();
            if (scope.value < minValue) {
              scope.value = minValue;
            }
            return snap();
          });
          scope.$watch('max()', function(maxValue) {
            parseIncrements();
            if (scope.value > maxValue) {
              scope.value = maxValue;
            }
            return snap();
          });
          scope.$watch('value', function(newVal, oldVal) {
            if (dragging) {
              return;
            }
            if (isFinite(newVal)) {
              if ((scope.min() <= newVal && newVal <= scope.max())) {
                return refreshHandle();
              } else {
                return scope.value = bound(newVal, scope.min(), scope.max());
              }
            } else {
              return scope.value = isFinite(oldVal) ? oldVal : scope.min();
            }
          });
          scope.step = function(steps) {
            var doIncrement, doStep;
            doStep = function(steps) {
              var newValue;
              newValue = scope.value + steps * step;
              if ((scope.min() <= newValue && newValue <= scope.max())) {
                return scope.value = newValue;
              }
            };
            doIncrement = function(steps) {
              var newVal, sv;
              newVal = steps > 0 ? ((function() {
                var _i, _len, _ref, _results;
                _ref = scope.snapValues;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  sv = _ref[_i];
                  if (sv > scope.value) {
                    _results.push(sv);
                  }
                }
                return _results;
              })())[0] : ((function() {
                var _i, _len, _ref, _results;
                _ref = scope.snapValues;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  sv = _ref[_i];
                  if (sv < scope.value) {
                    _results.push(sv);
                  }
                }
                return _results;
              })()).reverse()[0];
              if (newVal != null) {
                return scope.value = newVal;
              }
            };
            if (attrs.increments != null) {
              return doIncrement(steps);
            } else {
              return doStep(steps);
            }
          };
          scope.sliderClick = function($event) {
            var offsetX, _ref, _ref1;
            if (angular.element($event.target).hasClass('handle')) {
              return;
            }
            offsetX = (_ref = $event.layerX) != null ? _ref : (_ref1 = $event.originalEvent) != null ? _ref1.layerX : void 0;
            scope.xPosition = offsetX / sliderElement.offsetWidth * 100;
            scope.value = valueFromPosition();
            return snap();
          };
          startPointX = null;
          scope.handleMouseDown = function($event) {
            if (!angular.element($event.target).hasClass('handle')) {
              return;
            }
            startPointX = $event.pageX;
            return dragging = true;
          };
          $document.on('mousemove', function($event) {
            var moveDelta;
            if (!dragging) {
              return;
            }
            moveDelta = $event.pageX - startPointX;
            scope.xPosition += moveDelta / sliderElement.offsetWidth * 100;
            if (scope.xPosition < 0) {
              scope.xPosition = 0;
            } else if (scope.xPosition > 100) {
              scope.xPosition = 100;
            } else {
              startPointX = $event.pageX;
            }
            if (!deferUpdate) {
              scope.value = valueFromPosition();
            }
            if (scope.showValueInHandle) {
              scope.handleValue = valueFromPosition();
            }
            return scope.$apply();
          });
          return $document.on('mouseup', function() {
            if (!dragging) {
              return;
            }
            if (deferUpdate) {
              scope.value = valueFromPosition();
            }
            snap();
            scope.$apply();
            return dragging = false;
          });
        }
      };
    }
  ]);

  gliderModule.filter('intersperse', function() {
    return function(input) {
      var reverseString, reversed, sliced;
      if (input == null) {
        return;
      }
      input = input.toString();
      reverseString = function(input) {
        return input.split('').reverse().join('');
      };
      reversed = reverseString(input);
      reversed = reversed.replace(/(.{3})/g, '$1 ');
      sliced = reverseString(reversed);
      return sliced.trim();
    };
  });

}).call(this);

/*
//@ sourceMappingURL=glider.map
*/
